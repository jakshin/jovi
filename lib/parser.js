// Jovi's parser.
// It generates an AST from a list of Rockstar tokens.

const { PREFIXES, PRONOUNS, ASSIGMENT, ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION, ALL_ARITHMETIC,
  COMPARISON, GREATER, LESS, GREATER_OR_EQUAL, LESS_OR_EQUAL, UNDEFINED, NULL, TRUE, FALSE, MAYBE, ALL_LITERALS,
  INPUT, OUTPUT, ALL_KEYWORDS } = require("./keywords")

const { countAlphabeticalChars, isCapitalized, isLowerCase, parseNumeric } = require("./utils/strings")
const { init, more, peek, peekMany, pop, popLine, rewind } = require("./tokenList")
const { TokenType } = require("./tokenType")
const AST = require("./ast/ast")
const ArgumentList = require("./ast/argumentList")
const Expression = require("./ast/expression")

/**
 * Parses a list of Rockstar tokens, as generated by tokenize(), into an AST.
 * It won't change the passed list itself, but it DOES mutate tokens inside the list.
 */
function parse(tokens) {
  const ast = new AST()

  // remove all comments, and leading linebreaks
  tokens = tokens.filter((token) => token.type !== TokenType.COMMENT)

  while (true) {
    if (!tokens.length) return ast  // empty program
    if (tokens[0].type !== TokenType.LINEBREAK) break
    tokens.splice(0, 1)
  }

  // now we can easily detect blank lines (a line with only a comment counts as blank)
  let lastWasLinebreak = false

  tokens.forEach((token) => {
    const thisIsLinebreak = token.type === TokenType.LINEBREAK
    if (lastWasLinebreak && thisIsLinebreak) token.type = TokenType.BLANK_LINE
    lastWasLinebreak = thisIsLinebreak
  })

  // calculate each default token's "value"
  tokens.forEach((token) => {
    if (token.type === TokenType.DEFAULT) {
      token.value = token.str.toLowerCase()
    }
  })

  // let's do this
  init(tokens)
  return parseAllStatements(ast)
}

// ------------------------- Parser Loop & Statement Parsers -------------------------
// Statement parsers are called only from the main parser loop.
// Each takes the last-popped token as an argument, may advance the token list, and adds directly to the AST.

const state = {
  lastNamedVar: null,  // !!! per function?
}

/**
 * Parses all statements in the list of tokens, looping until completion,
 * adding the appropriate nodes to the given AST.
 */
function parseAllStatements(ast) {
  let justClosedIfBlock = false  // did we just complete an `if` or `else if` block?

  while (true) {
    if (!more()) return ast  // end of program
    const token = pop()

    if (token.type === TokenType.END_ALL_BLOCKS) {
      justClosedIfBlock = false  // can't if/else across concatenated files
      ast.endAllBlocks()
      continue
    }
    if (token.type === TokenType.BLANK_LINE) {
      justClosedIfBlock = ast.currentBlockIsIf()
      ast.endBlock()
      continue
    }

    if (token.value === "put") {
      parseAssignmentStatement(token, ast)
    }
    else if (token.value === "build" || token.value === "knock") {
      parseIncrementOrDecrementStatement(token, ast)
    }
    else if (token.value === "if" || token.value === "else") {
      // !!! should allow "otherwise" as a synonym for "else"; "or if" for "else if"?
      parseConditionalStatement(token, ast, justClosedIfBlock)
    }
    else if (token.value === "while" || token.value === "until") {
      ast.addLoop(parseExpression(), token.value === "until")
    }
    else if (token.value === "break") {
      parseBreakStatement(token, ast)
    }
    else if (token.value === "continue" || (token.value === "take" && parseMultiWordKeyword(token, "take it to the top"))) {
      parseContinueStatement(token, ast)
    }
    else if (INPUT.includes(token.value)) {
      parseInputStatement(token, ast)
    }
    else if (OUTPUT.includes(token.value)) {
      ast.addOutput(parseExpression())
    }
    else if (token.value === "give" && parseMultiWordKeyword(token, "give back")) {
      parseReturnStatement(token, ast)  // return from function
    }
    else if (startsVariable(token, true)) {
      // variable assignment, function declaration or function call
      parseAssignmentOrFunctionStatement(token, ast)
    }
    else {
      throw { message: `Unexpected word '${token.str}' here`, token }
    }

    justClosedIfBlock = false
  }
}

/**
 * Parses a "put" assignment statement, which assigns an expression's value to a variable.
 * You can also assign variables with the same syntax used to create and call functions,
 * which is handled in parseAssignmentOrFunctionStatement(), not here.
 */
function parseAssignmentStatement(token, ast) {
  const expression = parseExpression()

  const intoToken = pop()
  if (intoToken.value !== "into") {
    throw { message: `Unexpected word '${intoToken.str}' here; must be: into`, token: intoToken }
  }

  const { variableName } = parseVariable()
  ast.addAssignment(variableName, expression)
}

/**
 * Parses an increment or decrement statement.
 */
function parseIncrementOrDecrementStatement(token, ast) {
  const { variableName } = parseVariable()

  const terminator = (token.value === "build") ? "up" : "down"
  const endToken = pop()
  if (endToken.value !== terminator) {
    throw { message: `Unexpected word '${endToken.str}' here; must be: ${terminator}`, token: endToken }
  }

  let scale = 1
  while (more() && peek().value === terminator) {
    pop()
    scale++
  }

  if (token.value !== "build") scale = -scale
  ast.addIncrementOrDecrement(variableName, scale)
}

/**
 * Parses a statement that starts a conditional block ("if", "else if", "else");
 * "else if" and "else" must follow "if" or "else if", so it needs to know whether an if block was just closed.
 */
function parseConditionalStatement(token, ast, justClosedIfBlock) {
  if (token.value === "else") {
    // if the current block is an "if" or "else if", end it and allow this new block to start
    if (ast.currentBlockIsIf()) {
      ast.endBlock()
      justClosedIfBlock = true
    }

    // the last block closed must have been an "if" or "else if", or this keyword is an error
    if (!justClosedIfBlock) {
      throw { message: `Unexpected keyword '${token.str}' here; must immediately follow the end of an 'if' block`, token }
    }
  }

  let keyword = token.value
  if (keyword === "else" && peek(false).value === "if") {
    keyword = "else if"  // flatten `else if`, rather than making an `else` block which contains only an `if` block
    pop()
  }

  if (keyword === "else") ast.addElse()
  else ast.addIf(parseExpression(), keyword === "else if")
}

/**
 * Parses a "break" statement, which must be inside a loop.
 */
function parseBreakStatement(token, ast) {
  const keyword = parseMultiWordKeyword(token, "break it down") ? "break it down" : token.str
  if (!ast.inLoopBlock()) {
    throw { message: `Unexpected keyword '${keyword}' here; must be used inside a 'while' or 'until' loop`, token }
  }

  ast.addBreak()
}

/**
 * Parses a "continue" statement, which must be inside a loop.
 */
function parseContinueStatement(token, ast) {
  const keyword = (token.value === "continue") ? token.str : "take it to the top"
  if (!ast.inLoopBlock()) {
    throw { message: `Unexpected keyword '${keyword}' here; must be used inside a 'while' or 'until' loop`, token }
  }

  ast.addContinue()
}

/**
 * Parses an "input" statement.
 */
function parseInputStatement(token, ast) {
  let variableName
  if (parseMultiWordKeyword(token, "listen to")) {
    ({ variableName } = parseVariable())
  }

  ast.addInput(variableName)
}

/**
 * Parses a "return" statement, which must be inside a function.
 */
function parseReturnStatement(token, ast) {
  if (!ast.inFunctionBlock()) {
    throw { message: `Unexpected keyword '${token.str}' here; must be used inside a function`, token }
  }

  let variableName, literalType, literalValue

  if (!more() || peek().type === TokenType.BLANK_LINE) {
    // the function block ends without a return value being given; as a special case,
    // we treat this as `give back mysterious` (same effect as leaving out `give back`);
    // every function has a return value, per spec, but it can be `mysterious`, explicitly or implicitly
    literalType = "undefined"
  }
  else {
    // !!! support full expression here
    let nextToken = peek()

    if (nextToken.type === TokenType.NUMERIC_LITERAL) {
      // numeric literal
      nextToken = pop(false)
      literalType = "number"
      literalValue = parseNumericLiteral(nextToken)
    }
    else if (nextToken.type === TokenType.STRING_LITERAL) {
      // string literal
      nextToken = pop(false)
      literalType = "string"
      literalValue = nextToken.str
    }
    else if (ALL_LITERALS.includes(nextToken.value)) {
      // type literal
      nextToken = pop();
      ({ literalType, literalValue } = parseTypeLiteral(nextToken))
    }
    else if (startsVariable(nextToken)) {
      // variable
      ({ variableName } = parseVariable())
    }
    else {
      throw { message: `Unexpected word '${nextToken.str}' here`, token: nextToken }
    }

    if (variableName) ast.addFunctionReturn(variableName)
    else ast.addFunctionReturnWithLiteral(literalType, literalValue)
  }
}

/**
 * Parses a statement which begins with a variable name (or pronoun),
 * and which might either assign a variable's value from an expression or poetic literal,
 * declare a function, or call a function.
 */
function parseAssignmentOrFunctionStatement(token, ast) {
  rewind(token)
  const { variableName, possessive } = parseVariable(true)
  const keywordToken = possessive ? null : pop()
  const keyword = possessive ? "is" : keywordToken.value

  if (ASSIGMENT.includes(keyword)) {
    let literalType, literalValue, expression

    if (keyword === "says") {
      // poetic string literal
      literalType = "string"
      literalValue = parsePoeticStringLiteral(keywordToken, popLine())
    }
    else {
      // we need to support an expression here if the word following is/are/was/were is a type literal,
      // based on this example from the spec: `My world is nothing without your love`;
      // we also allow the expression to begin with a numeric/string literal
      const nextToken = peek()
      if ([TokenType.NUMERIC_LITERAL, TokenType.STRING_LITERAL].includes(nextToken.type) || ALL_LITERALS.includes(nextToken.value)) {
        expression = parseExpression()
      }
      else {
        // poetic number literal
        literalType = "number"
        literalValue = parsePoeticNumberLiteral(popLine())
      }
    }

    if (expression) ast.addAssignment(variableName, expression)
    else ast.addAssignmentWithLiteral(variableName, literalType, literalValue)
  }
  else if (keyword === "takes") {
    // function declaration

    // we only allow function declaration at global scope, i.e. not in another function, conditional, or loop
    // (the spec doesn't say anything explicit about this one way or the other)
    if (ast.inAnyBlock()) {
      throw { message: "Functions must be declared at global scope, outside conditionals and loops", token }
    }

    const argumentList = parseFunctionArguments(false)
    ast.addFunctionDeclaration(variableName, argumentList)
  }
  else if (keyword === "taking") {
    // function call
    const argumentList = parseFunctionArguments(true)
    ast.addFunctionCall(variableName, argumentList)
  }
  else {
    // we don't understand the word which follows the variable name
    const expected = ASSIGMENT.concat("takes", "taking").join(" ")
    throw { message: `Unexpected word '${keywordToken.str}' here; must be one of: ${expected}`, token: keywordToken }
  }
}

// ------------------------- Parsing Utilities -------------------------
// These can be called from any statement parser, and from each other.
// Some of them advance the token list.

/**
 * Parses a multi-word keyword, consuming tokens as needed if the last-popped token begins one,
 * and leaving the token list as-is if not. Returns a boolean indicating whether the multi-word keyword was parsed.
 * You must pass the multi-word keyword phrase in lowercase and separated only by single spaces.
 */
function parseMultiWordKeyword(lastPoppedToken, keywordPhrase) {
  const words = keywordPhrase.split(" ")
  const upcomingCount = words.length - 1
  const tokens = [lastPoppedToken].concat(peekMany(upcomingCount))

  for (let index = 0; index < words.length; index++) {
    const token = tokens.shift()
    if (!token || token.type !== TokenType.DEFAULT || token.value !== words[index]) {
      return false
    }
  }

  for (let index = 0; index < upcomingCount; index++) pop()
  return true
}

/**
 * Parses an expression, consuming tokens as needed; it should be called only when an expression is expected.
 * Returns an Expression instance, which will always contain at least one operand, as its first term.
 */
function parseExpression() {
  const expression = new Expression()
  let expectingOperand = true

  while (true) {
    if (expectingOperand) {
      const token = peek()
      const { variableName, literalType, literalValue } = parseVariableOrLiteral()

      if (!variableName && !literalType) {
        throw { message: `Unexpected word '${token.str}' here; must be a variable name or literal value`, token }
      }

      // !!! allow a semi-colon to terminate function args if you want a boolean "and" right after a function call?
      if (variableName && more() && peek().value === "taking") {
        // we have a function call inside the expression
        pop()  // consume "taking"
        const argumentList = parseFunctionArguments(true)
        expression.addFunctionCallOperand(variableName, argumentList)
      }
      else {
        if (variableName) expression.addVariableOperand(variableName)
        else expression.addLiteralOperand(literalType, literalValue)
      }

      expectingOperand = false
      if (!more()) break  // end of input
    }
    else if (more()) {
      // we might have a arithmetic, comparison, or boolean operator next, or the expression might be complete;
      // references for operator precedence: http://us1.php.net/manual/en/language.operators.precedence.php,
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

      const nextToken = peek()
      if (nextToken.type !== TokenType.DEFAULT) break

      if (ALL_ARITHMETIC.includes(nextToken.value)) {
        const operator = parseArithmeticOperator()
        const precedence = (operator === "+" || operator === "-") ? 20 : 21
        expression.addArithmeticOperator(operator, precedence)
      }
      else if (COMPARISON.includes(nextToken.value)) {
        const operator = parseComparisonOperator()
        const precedence = (operator === "==" || operator === "!=") ? 10 : 11
        expression.addComparisonOperator(operator, precedence)
      }
      else if (nextToken.value === "and" || nextToken.value === "or") {
        const operator = pop().value
        const precedence = operator === "or" ? 1 : 2
        expression.addBooleanOperator(operator, precedence)
      }
      else {
        break  // guess the expression is complete
      }

      expectingOperand = true
    }
  }

  return expression
}

/**
 * Parses an arithmetic operator, consuming one token; it should be called only when an arithmetic operator is expected.
 * Returns a string containing the operator.
 */
function parseArithmeticOperator() {
  const token = pop()

  if (ADDITION.includes(token.value)) return "+"
  if (SUBTRACTION.includes(token.value)) return "-"
  if (MULTIPLICATION.includes(token.value)) return "*"
  if (DIVISION.includes(token.value)) return "/"

  const expected = ALL_ARITHMETIC.join(" ")
  throw { message: `Unexpected word '${token.value}' here; must be one of: ${expected}`, token }
}

/**
 * Parses a comparison operator, consuming tokens as needed; it should be called only when a comparison operator is expected.
 * Returns a string containing the operator.
 */
function parseComparisonOperator() {
  const firstToken = pop()
  if (!COMPARISON.includes(firstToken.value)) {
    const expected = COMPARISON.join(" ")
    throw { message: `Unexpected word '${firstToken.str}' here; must be one of: ${expected}`, token: firstToken }
  }

  let positive = (firstToken.value === "is")
  while (peek().value === "not") {
    positive = !positive
    pop()
  }

  let orEquals = false
  if (peek().value === "as") {
    orEquals = true
    pop()
  }

  let operator

  if (orEquals) {
    const token = pop()

    if (GREATER_OR_EQUAL.includes(token.value)) {
      operator = positive ? ">=" : "<"
    }
    else if (LESS_OR_EQUAL.includes(token.value)) {
      operator = positive ? "<=" : ">"
    }
    else {
      // because the "as" keyword is present, we needed a comparison keyword
      const expected = GREATER_OR_EQUAL.concat(LESS_OR_EQUAL).join(" ")
      throw { message: `Unexpected word '${token.str}' here; must be one of: ${expected}`, token }
    }

    const nextToken = pop()
    if (nextToken.value !== "as") {
      throw { message: `Unexpected word '${nextToken.str}' here; must be: as`, token: nextToken }
    }
  }
  else {
    const token = peek()
    let requireThan = true  // do we need "than", because we just parsed a comparison keyword?

    if (GREATER.includes(token.value)) {
      operator = positive ? ">" : "<="
      pop()  // consume the peeked keyword
    }
    else if (LESS.includes(token.value)) {
      operator = positive ? "<" : ">="
      pop()  // consume the peeked keyword
    }
    else {
      // a comparison keyword isn't present; assume this is an equality comparison
      operator = positive ? "==" : "!="
      requireThan = false
    }

    if (requireThan) {
      const nextToken = pop()
      if (nextToken.value !== "than") {
        throw { message: `Unexpected word '${nextToken.str}' here; must be: than`, token: nextToken }
      }
    }
  }

  return operator
}

/**
 * Parses function arguments, starting just after "takes" or "taking", consuming tokens as needed.
 * Returns an ArgumentList instance.
 *
 * For function declarations, each argument must be a variable name, and only `var` will ever be set.
 * For function calls, arguments can also be numeric/string/type literals, and `literalType`/`literalValue` might be set instead.
 * In either case, arguments may be separated by commas and/or the "and" keyword, which are not returned.
 */
function parseFunctionArguments(forFunctionCall) {
  const argumentList = new ArgumentList(forFunctionCall)
  let optional = false

  while (true) {
    const token = peek()
    let variableName, literalType, literalValue, punctuation

    if (forFunctionCall) {
      ({ variableName, literalType, literalValue, punctuation } = parseVariableOrLiteral())

      if (!variableName && !literalType) {
        if (optional) break  // an argument wasn't required at this point; we're done here
        throw { message: `Unexpected word '${token.str}' here; must be a variable name or literal value`, token }
      }

      if (variableName) argumentList.addArgument(variableName)
      else argumentList.addArgumentWithLiteral(literalType, literalValue)
    }
    else {
      ({ variableName, punctuation } = parseVariable(false, false))

      if (!variableName) {
        if (optional) break  // an argument wasn't required at this point; we're done here
        throw { message: `Unexpected word '${token.str}' here; must be a parameter name, using variable naming rules`, token }
      }

      argumentList.addArgument(variableName)
    }

    if (!more()) break
    if (peek().value === "and") {
      optional = false  // we require another argument after "and"
      pop()             // consume the "and"
    }
    else if (punctuation.endsWith(",")) {
      optional = true   // since this argument's token ended with a comma, we'll optionally take another argument
    }
    else {
      break  // next word isn't "and", and there's no comma ending this token, so we're done
    }
  }

  return argumentList
}

/**
 * Parses for a variable name or literal value, consuming tokens as needed.
 * Returns an object containing four properties: `variableName`, `literalType`, `literalValue` and `punctuation`.
 * Populates either `variableName`, or `literalType` and `literalValue`, but noth both; if neither is populated,
 * that means it couldn't parse a variable name OR numeric/string/type literal.
 */
function parseVariableOrLiteral() {
  let variableName, literalType, literalValue, punctuation
  const token = pop(false)

  if (token.type === TokenType.NUMERIC_LITERAL) {
    literalType = "number"
    literalValue = parseNumericLiteral(token)
    punctuation = token.punctuation
  }
  else if (token.type === TokenType.STRING_LITERAL) {
    literalType = "string"
    literalValue = token.str
    punctuation = token.punctuation
  }
  else if (ALL_LITERALS.includes(token.value)) {
    ({ literalType, literalValue } = parseTypeLiteral(token))
    punctuation = token.punctuation
  }
  else if (startsVariable(token)) {
    rewind(token);
    ({ variableName, punctuation } = parseVariable())
  }

  return { variableName, literalType, literalValue, punctuation }
}

/**
 * Parses for a variable name, consuming tokens as needed; it should be called only when a variable name is expected.
 * Returns an object containing three properties: `variableName` (the parsed variable's full name),
 * `possessive` (boolean, always false if allowPossessive isn't passed as a truthy value), and
 * `punctuation` (the trailing punctuation, if any, of the last token forming the variable's name).
 *
 * When a pronoun is parsed, the last named variable's name is returned.
 * When a common variable is parsed, its prefix is returned lowercase.
 * Proper variables are returned in the case given, with each word capitalized.
 */
function parseVariable(allowPossessive = false, allowPronoun = true) {
  const firstToken = pop()

  // is it a pronoun?
  // xxx need to handle possessive pronouns
  if (PRONOUNS.includes(firstToken.value)) {
    if (!allowPronoun) {
      throw { message: `Can't use pronoun '${firstToken.str}' here; use named variables in function declarations`, token: firstToken }
    }
    else if (!state.lastNamedVar) {
      throw { message: `Can't use pronoun '${firstToken.str}' here; a named variable must be used first`, token: firstToken }
    }

    return { variableName: state.lastNamedVar, punctuation: firstToken.punctuation }
  }

  // is it a common variable?
  if (PREFIXES.includes(firstToken.value)) {
    const secondToken = pop()
    if (ALL_KEYWORDS.includes(secondToken.value)) {
      throw { message: `Unexpected keyword '${secondToken.str}' here`, token: secondToken }
    }

    let secondWord = secondToken.str, possessive = false
    if (allowPossessive && secondWord.toLowerCase().endsWith("'s")) {
      secondWord = secondWord.slice(0, -2)
      possessive = true
    }

    if (ALL_KEYWORDS.includes(secondWord.toLowerCase())) {
      throw { message: `Unexpected possessive keyword '${secondWord}' here`, token }
    }

    if (!isLowerCase(secondWord)) {
      throw { message: "Common variables must be lowercase and all alphabetical", token: secondToken }
    }

    if (firstToken.punctuation !== "") {
      throw { message: "Common variables must be all alphabetical (you can use punctuation only after their last word)", token: firstToken }
    }

    const variableName = `${firstToken.value} ${secondWord}`
    state.lastNamedVar = variableName
    return { variableName, possessive, punctuation: secondToken.punctuation }
  }

  // well then it must be a proper variable (or garbage)
  let variableName = ""
  let possessive = false
  let token = firstToken

  while (true) {
    if (ALL_KEYWORDS.includes(token.value)) {
      throw { message: `Unexpected keyword '${token.str}' here`, token }
    }

    let word = token.str
    if (allowPossessive && word.toLowerCase().endsWith("'s")) {
      word = word.slice(0, -2)
      possessive = true
    }

    if (ALL_KEYWORDS.includes(word.toLowerCase())) {
      throw { message: `Unexpected possessive keyword '${token.str}' here`, token }
    }

    if (!isCapitalized(word)) {
      throw { message: "Proper variables must be capitalized and all alphabetical", token }
    }

    if (variableName) variableName += " "
    variableName += word

    if (possessive) break
    if (token.punctuation.endsWith(",")) {
      break  // a trailing comma ends the variable, in case we're in a function's argument list
    }

    if (!more()) break
    const nextToken = peek()
    if (nextToken.type !== TokenType.DEFAULT || ALL_KEYWORDS.includes(nextToken.value)) break

    const str = (allowPossessive && nextToken.str.toLowerCase().endsWith("'s")) ? nextToken.str.slice(0, -2) : nextToken.str
    if (!isCapitalized(str)) break

    if (token.punctuation !== "") {
      // the variable has another word in it, so don't allow punctuation here
      // !!! just stop parsing for more words in the variable if this word has punctuation, instead of throwing?
      throw { message: "Proper variables must be all alphabetical (you can use punctuation only after their last word)", token }
    }

    token = pop()
  }

  state.lastNamedVar = variableName
  return { variableName, possessive, punctuation: token.punctuation }
}

/**
 * Parses a type literal from a single token.
 * Returns an object with `literalType` and `literalValue` properties.
 */
function parseTypeLiteral(fromToken) {
  if (UNDEFINED.includes(fromToken.value))
    return { literalType: "undefined", literalValue: undefined }
  if (NULL.includes(fromToken.value))
    return { literalType: "null", literalValue: null }
  if (TRUE.includes(fromToken.value))
    return { literalType: "boolean", literalValue: true }
  if (FALSE.includes(fromToken.value))
    return { literalType: "boolean", literalValue: false }

  if (MAYBE.includes(fromToken.value)) {
    throw { message: `Type literal '${fromToken.str}' is reserved for future use`, token: fromToken }
  }

  throw { message: `Invalid type literal '${fromToken.str}'`, token: fromToken }
}

/**
 * Parses a poetic string literal from the `says` token and all tokens following it on the line.
 * Returns the string parsed, or the empty string if there are no tokens to parse.
 */
function parsePoeticStringLiteral(saysToken, restOfLineTokens) {
  let str = saysToken.whitespace.slice(1)

  for (const token of restOfLineTokens) {
    const quote = (token.type === TokenType.STRING_LITERAL) ? '"' : ""
    str += `${quote}${token.str}${quote}${token.punctuation}${token.whitespace}`
  }

  return str
}

/**
 * Parses a poetic number literal from a list of tokens which follow is/are/was/were on a line.
 * Returns the number parsed, or 0 if there are no tokens to parse.
 */
function parsePoeticNumberLiteral(restOfLineTokens) {
  if (!restOfLineTokens.length) return 0  // if there are no tokens on the line after the is/are/was/were keyword

  let numStr = ""

  for (const token of restOfLineTokens) {
    const words = token.str.split(/\s+/)  // the token could be a string literal

    for (const wordNum in words) {
      const word = words[wordNum]

      const alphaCharCount = countAlphabeticalChars(word)
      if (alphaCharCount) numStr += alphaCharCount % 10
      if (word.endsWith(".") && !numStr.includes(".")) numStr += "."
    }

    if (token.punctuation.includes(".") && !numStr.includes(".")) numStr += "."
  }

  const num = parseNumeric(numStr)

  if (isNaN(num) || !isFinite(num)) {
    const firstToken = restOfLineTokens[0]
    throw { message: `Invalid poetic number literal '${firstToken.str} ...' (${num})`, firstToken }
  }

  return num
}

/**
 * Parses and returns a numeric literal token's numeric value.
 */
function parseNumericLiteral(token) {
  const num = parseNumeric(token.str)

  if (isNaN(num) || !isFinite(num)) {
    throw { message: `Invalid numeric literal '${token.str}'  (${num})`, token }
  }

  return num
}

/**
 * Determines whether the passed token appears to start a variable's name,
 * by being a pronoun, common variable, or proper variable.
 */
function startsVariable(token, allowPossessive = false) {
  if (PRONOUNS.includes(token.value)) return true
  if (PREFIXES.includes(token.value)) return true

  const str = (allowPossessive && token.str.toLowerCase().endsWith("'s")) ? token.str.slice(0, -2) : token.str
  if (isCapitalized(str) && !ALL_KEYWORDS.includes(token.value)) return true

  return false
}

module.exports = { parse }
