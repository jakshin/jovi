// Jovi's parser.
// It generates an AST from a list of Rockstar tokens.

const { countAlphabeticalChars, isCapitalized, isLowerCase } = require("./utils/strings")
const { init, more, peek, peekMany, pop, popLine, rewind } = require("./tokenList")
const { TokenType } = require("./tokenType")
const AST = require("./ast/ast")
const ArgumentList = require("./ast/argumentList")
const Expression = require("./ast/expression")

// ------------------------- Keywords -------------------------

// variables
const PREFIXES = ["a", "an", "the", "my", "your"]
const PRONOUNS = ["it", "he", "she", "him", "her", "they", "them", "ze", "hir", "zie", "zir", "xe", "xem", "ve", "ver"]

// assigment operator
const ASSIGMENT = ["is", "was", "were", "says"]

// arithmetic operators
const ADDITION = ["plus", "with"]
const SUBTRACTION = ["minus", "without"]
const MULTIPLICATION = ["times", "of"]
const DIVISION = ["over"]
const ALL_ARITHMETIC = [].concat(ADDITION, SUBTRACTION, MULTIPLICATION, DIVISION)

// comparison operators
const COMPARISON = ["is", "ain't", "aint"]  // !!! should also allow "are", "aren't", "isn't"
const GREATER = ["higher", "greater", "bigger", "stronger"]
const LESS = ["lower", "less", "smaller", "weaker"]
const GREATER_OR_EQUAL = ["high", "great", "big", "strong"]
const LESS_OR_EQUAL = ["low", "little", "small", "weak"]

// type literals ("literal words")
const UNDEFINED = ["mysterious"]
const NULL = ["null", "nothing", "nowhere", "nobody", "empty", "gone"]
const TRUE = ["true", "right", "yes", "ok"]
const FALSE = ["false", "wrong", "no", "lies"]
const MAYBE = ["maybe", "definitely"]  // reserved but unused
const ALL_LITERALS = [].concat(UNDEFINED, NULL, TRUE, FALSE, MAYBE)

// built-in I/O
const INPUT = ["listen"]
const OUTPUT = ["say", "shout", "whisper", "scream"]

// other reserved keywords not mentioned above
const OTHER_KEYWORDS = [
  "put", "into",                             // assignment
  "build", "up", "knock", "down",            // increment and decrement
  "if", "else", "while", "until",            // conditionals and loops
  "break", "continue", "take", "to", "top",  // loop flow control
  "takes", "taking", "give", "back",         // functions
  "as", "than", "not",                       // used in comparison expressions
  "and", "or",                               // used in expressions, function declarations
]

// all the keywords
const ALL_KEYWORDS = [].concat(
  PREFIXES, PRONOUNS,
  ASSIGMENT,
  ALL_ARITHMETIC,
  COMPARISON, GREATER, LESS, GREATER_OR_EQUAL, LESS_OR_EQUAL,
  ALL_LITERALS,
  INPUT, OUTPUT,
  OTHER_KEYWORDS
)

// ------------------------- Globals -------------------------

const state = {
  lastNamedVar: null,  // !!! per function?
}

// ------------------------- Public API -------------------------

/**
 * Parses a list of Rockstar tokens, as generated by tokenize(), into an AST.
 * It won't change the passed list itself, but it DOES mutate tokens inside the list.
 */
function parse(tokens) {
  const ast = new AST()

  // remove all comments, and leading linebreaks
  tokens = tokens.filter((token) => token.type !== TokenType.COMMENT)

  while (true) {
    if (!tokens.length) return ast  // empty program
    if (tokens[0].type !== TokenType.LINEBREAK) break
    tokens.splice(0, 1)
  }

  // now we can easily detect blank lines (a line with only a comment counts as blank)
  let lastWasLinebreak = false

  tokens.forEach((token) => {
    const thisIsLinebreak = token.type === TokenType.LINEBREAK
    if (lastWasLinebreak && thisIsLinebreak) token.type = TokenType.BLANK_LINE
    lastWasLinebreak = thisIsLinebreak
  })

  // calculate each default token's "value"
  tokens.forEach((token) => {
    if (token.type === TokenType.DEFAULT) {
      token.value = token.str.toLowerCase()
    }
  })

  // let's do this
  init(tokens)
  return parseAllStatements(ast)
}

// ------------------------- Parser Loop -------------------------

/**
 * Parses all statements in the list of tokens, looping until completion,
 * adding the appropriate nodes to the given AST.
 */
function parseAllStatements(ast) {
  let justClosedIfBlock = false  // did we just complete an `if` or `else if` block?

  while (true) {
    if (!more()) return ast  // end of program
    const token = pop()

    if (token.type === TokenType.END_ALL_BLOCKS) {
      justClosedIfBlock = false  // can't if/else across concatenated files
      ast.endAllBlocks()
      continue
    }
    if (token.type === TokenType.BLANK_LINE) {
      justClosedIfBlock = ast.currentBlockIsIf()
      ast.endBlock()
      continue
    }

    // !!!
    // error messages which say "unexpected word" below could be confusing if the token is actually a string literal,
    // which is likely more than one word... also if end-all-blocks

    if (token.value === "put") {
      // variable assignment
      const expressionTerms = parseExpression()

      const intoToken = pop()
      if (intoToken.value !== "into") {
        throw { message: `Unexpected word '${intoToken.str}' here; must be: into`, token: intoToken }
      }

      const { variableName } = parseVariable()
      ast.addAssignment(variableName, expressionTerms)
    }
    else if (token.value === "build" || token.value === "knock") {
      // increment or decrement statement
      const { variableName } = parseVariable()

      const terminator = (token.value === "build") ? "up" : "down"
      const endToken = pop()
      if (endToken.value !== terminator) {
        throw { message: `Unexpected word '${endToken.str}' here; must be: ${terminator}`, token: endToken }
      }

      ast.addIncrementOrDecrement(variableName, token.value === "build")
    }

    else if (token.value === "if" || token.value === "else") {
      // conditional block
      // !!! should allow "otherwise" as a synonym for "else"; "or if" for "else if"?

      if (token.value === "else" && !justClosedIfBlock) {
        throw { message: `Unexpected keyword '${token.str}' here; must immediately follow the end of an 'if' block`, token }
      }

      let keyword = token.value
      if (keyword === "else" && peek().value === "if") {
        keyword = "else if"  // flatten `else if`, rather than making an `else` block which contains only an `if` block
        pop()
      }

      if (keyword === "else") ast.addElse()
      else ast.addIf(parseExpression(), keyword === "else if")
    }

    else if (token.value === "while" || token.value === "until") {
      ast.addLoop(parseExpression(), token.value === "until")
    }
    else if (token.value === "break") {
      // break out of loop

      const keyword = parseMultiWordKeyword(token, "break it down") ? "break it down" : token.str
      if (!ast.inLoopBlock()) {
        throw { message: `Unexpected keyword '${keyword}' here; must be used inside a 'while' or 'until' loop`, token }
      }

      ast.addBreak()
    }
    else if (token.value === "continue" || (token.value === "take" && parseMultiWordKeyword(token, "take it to the top"))) {
      // continue in loop

      const keyword = (token.value === "continue") ? token.str : "take it to the top"
      if (!ast.inLoopBlock()) {
        throw { message: `Unexpected keyword '${keyword}' here; must be used inside a 'while' or 'until' loop`, token }
      }

      ast.addContinue()
    }

    else if (INPUT.includes(token.value)) {
      // input statement

      let variableName
      if (parseMultiWordKeyword(token, "listen to")) {
        ({ variableName } = parseVariable())
      }

      ast.addInput(variableName)
    }
    else if (OUTPUT.includes(token.value)) {
      // output statement

      // although the spec only mentions outputting the value of a variable, we also allow a literal
      const nextToken = peek()
      const { variableName, literalType, literalValue } = parseVariableOrLiteral()

      if (!variableName && !literalType) {
        throw { message: `Unexpected word '${nextToken.str}' here; must be a variable name or literal value`, token: nextToken }
      }

      if (variableName) ast.addOutput(variableName)
      else ast.addOutputWithLiteral(literalType, literalValue)
    }

    else if (startsVariable(token)) {
      // variable assignment, function declaration or function call
      rewind(token)
      const { variableName } = parseVariable()
      const keywordToken = pop()
      const keyword = keywordToken.value

      if (ASSIGMENT.includes(keyword)) {
        let literalType, literalValue, expressionTerms

        if (keyword === "says") {
          // poetic string literal
          literalType = "string"
          literalValue = parsePoeticStringLiteral(popLine())
        }
        else {
          // we need to support an expression here if the word following is/was/were is a type literal,
          // based on this example from spec: `My world is nothing without your love`;
          // we also allow the expression to begin with a numeric/string literal
          const nextToken = peek()
          if ([TokenType.NUMERIC_LITERAL, TokenType.STRING_LITERAL].includes(nextToken.type) || ALL_LITERALS.includes(nextToken.value)) {
            expressionTerms = parseExpression()
          }
          else {
            // poetic number literal
            literalType = "number"
            literalValue = parsePoeticNumberLiteral(popLine())
          }
        }

        if (expressionTerms) ast.addAssignment(variableName, expressionTerms)
        else ast.addAssignmentWithLiteral(variableName, literalType, literalValue)
      }
      else if (keyword === "takes") {
        // function declaration

        // we only allow function declaration at global scope, i.e. not in another function, conditional, or loop
        // (the spec doesn't say anything explicit about this one way or the other)
        if (ast.inAnyBlock()) {
          throw { message: "Functions must be declared at global scope, outside conditionals and loops", token }
        }

        const argumentList = parseFunctionArguments(false)
        ast.addFunctionDeclaration(variableName, argumentList)
      }
      else if (keyword === "taking") {
        // function call
        const argumentList = parseFunctionArguments(true)
        ast.addFunctionCall(variableName, argumentList)
      }
      else {
        // we don't understand the word which follows the variable name
        const expected = ASSIGMENT.concat("takes", "taking").join(" ")
        throw { message: `Unexpected word '${keywordToken.str}' here; must be one of: ${expected}`, token: keywordToken }
      }
    }

    else if (token.value === "give" && parseMultiWordKeyword(token, "give back")) {
      // return from function
      if (!ast.inFunctionBlock()) {
        throw { message: `Unexpected keyword '${token.str}' here; must be used inside a function`, token }
      }

      let variableName, literalType, literalValue

      if (!more() || peek().type === TokenType.BLANK_LINE) {
        // the function block ends without a return value being given; as a special case,
        // we treat this as `give back mysterious` (same effect as leaving out `give back`);
        // every function has a return value, per spec, but it can be `mysterious`, explicitly or implicitly
        literalType = "undefined"
      }
      else {
        // !!! support full expression here
        let nextToken = peek()

        if (nextToken.type === TokenType.NUMERIC_LITERAL) {
          // numeric literal
          nextToken = pop(false)
          literalType = "number"
          literalValue = parseNumericLiteral(nextToken)
        }
        else if (nextToken.type === TokenType.STRING_LITERAL) {
          // string literal
          nextToken = pop(false)
          literalType = "string"
          literalValue = nextToken.str
        }
        else if (ALL_LITERALS.includes(nextToken.value)) {
          // type literal
          nextToken = pop();
          ({ literalType, literalValue } = parseTypeLiteral(nextToken))
        }
        else if (startsVariable(nextToken)) {
          // variable
          ({ variableName } = parseVariable())
        }
        else {
          throw { message: `Unexpected word '${nextToken.str}' here`, token: nextToken }
        }

        if (variableName) ast.addFunctionReturn(variableName)
        else ast.addFunctionReturnWithLiteral(literalType, literalValue)
      }
    }

    else {
      throw { message: `Unexpected word '${token.str}' here`, token }
    }

    justClosedIfBlock = false
  }
}

// ------------------------- Statement Parsers -------------------------

// !!!

// ------------------------- Parsing Utilities -------------------------

/**
 * Parses an expression, consuming tokens as needed; it should be called only when an expression is expected.
 * Returns an array of objects which comprise the expression's terms ("boolean", "math", "compare", or "operand").
 * At least one "operand" will always be present, and first.
 */
function parseExpression() {
  const expression = new Expression()
  let expectingVariableOrValue = true

  while (true) {
    if (expectingVariableOrValue) {
      const token = peek()
      const { variableName, literalType, literalValue } = parseVariableOrLiteral()

      if (!variableName && !literalType) {
        throw { message: `Unexpected word '${token.str}' here; must be a variable name or literal value`, token }
      }

      // !!! allow a semi-colon to terminate function args if you want a boolean "and" right after a function call?
      if (variableName && more() && peek().value === "taking") {
        // we have a function call inside the expression
        pop()  // consume "taking"
        const argumentList = parseFunctionArguments(true)
        expression.addFunctionCallOperand(variableName, argumentList)
      }
      else {
        if (variableName) expression.addVariableOperand(variableName)
        else expression.addLiteralOperand(literalType, literalValue)
      }

      expectingVariableOrValue = false
      if (!more()) break  // end of input
    }
    else if (more()) {
      // we might have a arithmetic, comparison, or boolean operator next, or the expression might be complete
      const nextToken = peek()
      if (nextToken.type !== TokenType.DEFAULT) break

      if (ALL_ARITHMETIC.includes(nextToken.value)) {
        const operator = parseArithmeticOperator()
        const precedence = (operator === "+" || operator === "-") ? 5 : 6
        expression.addArithmeticOperator(operator, precedence)
      }
      else if (COMPARISON.includes(nextToken.value)) {
        const operator = parseComparisonOperator()
        const precedence = (operator === "==" || operator === "!=") ? 3 : 4
        expression.addComparisonOperator(operator, precedence)
      }
      else if (nextToken.value === "and" || nextToken.value === "or") {
        const operator = pop().value
        const precedence = operator === "or" ? 1 : 2
        expression.addBooleanOperator(operator, precedence)
      }
      else {
        break  // guess the expression is complete
      }

      expectingVariableOrValue = true
    }
  }

  return expression
}

/**
 * Parses an arithmetic operator, consuming one token; it should be called only when an arithmetic operator is expected.
 * Returns a string containing the operator.
 */
function parseArithmeticOperator() {
  const token = pop()

  if (ADDITION.includes(token.value)) return "+"
  if (SUBTRACTION.includes(token.value)) return "-"
  if (MULTIPLICATION.includes(token.value)) return "*"
  if (DIVISION.includes(token.value)) return "/"

  const expected = ALL_ARITHMETIC.join(" ")
  throw { message: `Unexpected word '${token.value}' here; must be one of: ${expected}`, token }
}

/**
 * Parses a comparison operator, consuming tokens as needed; it should be called only when a comparison operator is expected.
 * Returns a string containing the operator.
 */
function parseComparisonOperator() {
  const firstToken = pop()
  if (!COMPARISON.includes(firstToken.value)) {
    const expected = COMPARISON.join(" ")
    throw { message: `Unexpected word '${firstToken.str}' here; must be one of: ${expected}`, token: firstToken }
  }

  let positive = (firstToken.value === "is")
  while (peek().value === "not") {
    positive = !positive
    pop()
  }

  let orEquals = false
  if (peek().value === "as") {
    orEquals = true
    pop()
  }

  let operator

  if (orEquals) {
    const token = pop()

    if (GREATER_OR_EQUAL.includes(token.value)) {
      operator = positive ? ">=" : "<"
    }
    else if (LESS_OR_EQUAL.includes(token.value)) {
      operator = positive ? "<=" : ">"
    }
    else {
      // because the "as" keyword is present, we needed a comparison keyword
      const expected = GREATER_OR_EQUAL.concat(LESS_OR_EQUAL).join(" ")
      throw { message: `Unexpected word '${token.str}' here; must be one of: ${expected}`, token }
    }

    const nextToken = pop()
    if (nextToken.value !== "as") {
      throw { message: `Unexpected word '${nextToken.str}' here; must be: as`, token: nextToken }
    }
  }
  else {
    const token = peek()
    let requireThan = true  // do we need "than", because we just parsed a comparison keyword?

    if (GREATER.includes(token.value)) {
      operator = positive ? ">" : "<="
      pop()  // consume the peeked keyword
    }
    else if (LESS.includes(token.value)) {
      operator = positive ? "<" : ">="
      pop()  // consume the peeked keyword
    }
    else {
      // a comparison keyword isn't present; assume this is an equality comparison
      operator = positive ? "==" : "!="
      requireThan = false
    }

    if (requireThan) {
      const nextToken = pop()
      if (nextToken.value !== "than") {
        throw { message: `Unexpected word '${nextToken.str}' here; must be: than`, token: nextToken }
      }
    }
  }

  return operator
}

/**
 * Parses function arguments, starting just after "takes" or "taking", consuming tokens as needed.
 * Returns an ArgumentList.
 *
 * For function declarations, each argument must be a variable name, and only `var` will ever be set.
 * For function calls, arguments can also be numeric/string/type literals, and `literalType`/`literalValue` might be set instead.
 * In either case, arguments may be separated by commas and/or the "and" keyword, which are not returned.
 */
function parseFunctionArguments(forFunctionCall) {
  const argumentList = new ArgumentList(forFunctionCall)
  let optional = false

  while (true) {
    const token = peek()
    let variableName, literalType, literalValue, punctuation

    if (forFunctionCall) {
      ({ variableName, literalType, literalValue, punctuation } = parseVariableOrLiteral())

      if (!variableName && !literalType) {
        if (optional) break  // an argument wasn't required at this point; we're done here
        throw { message: `Unexpected word '${token.str}' here; must be a variable name or literal value`, token }
      }

      if (variableName) argumentList.addArgument(variableName)
      else argumentList.addArgumentWithLiteral(literalType, literalValue)
    }
    else {
      ({ variableName, punctuation } = parseVariable(false))

      if (!variableName) {
        if (optional) break  // an argument wasn't required at this point; we're done here
        throw { message: `Unexpected word '${token.str}' here; must be a parameter name, using variable naming rules`, token }
      }

      argumentList.addArgument(variableName)
    }

    if (!more()) break
    if (peek().value === "and") {
      optional = false  // we require another argument after "and"
      pop()             // consume the "and"
    }
    else if (punctuation.endsWith(",")) {
      optional = true   // since this argument's token ended with a comma, we'll optionally take another argument
    }
    else {
      break  // next word isn't "and", and there's no comma ending this token, so we're done
    }
  }

  return argumentList
}

/**
 * Parses for a variable name or literal value, consuming tokens as needed.
 * Returns an object containing four properties: `variableName`, `literalType`, `literalValue` and `punctuation`.
 * Populates either `variableName`, or `literalType` and `literalValue`, but noth both; if neither is populated,
 * that means it couldn't parse a variable name OR numeric/string/type literal.
 */
function parseVariableOrLiteral() {
  let variableName, literalType, literalValue, punctuation
  const token = pop(false)

  if (token.type === TokenType.NUMERIC_LITERAL) {
    literalType = "number"
    literalValue = parseNumericLiteral(token)
    punctuation = token.punctuation
  }
  else if (token.type === TokenType.STRING_LITERAL) {
    literalType = "string"
    literalValue = token.str
    punctuation = token.punctuation
  }
  else if (ALL_LITERALS.includes(token.value)) {
    ({ literalType, literalValue } = parseTypeLiteral(token))
    punctuation = token.punctuation
  }
  else if (startsVariable(token)) {
    rewind(token);
    ({ variableName, punctuation } = parseVariable())
  }

  return { variableName, literalType, literalValue, punctuation }
}

/**
 * Parses for a variable name, consuming tokens as needed; it should be called only when a variable name is expected.
 * Returns an object containing two properties: `variableName`, and `punctuation`
 * (the trailing punctuation, if any, of the last token forming the variable's name).
 *
 * When a common variable is parsed, its prefix is returned lowercase;
 * when a pronoun is parsed, the last named variable's name is returned.
 * Proper variables are returned in the case given, with each word capitalized.
 */
function parseVariable(allowPronoun = true) {
  const firstToken = pop()

  if (PRONOUNS.includes(firstToken.value)) {
    if (!allowPronoun) {
      throw { message: `Can't use pronoun '${firstToken.str}' here; use named variables in function declarations`, token: firstToken }
    }
    else if (!state.lastNamedVar) {
      throw { message: `Can't use pronoun '${firstToken.str}' here; a named variable must be used first`, token: firstToken }
    }

    return { variableName: state.lastNamedVar, punctuation: firstToken.punctuation }
  }

  if (PREFIXES.includes(firstToken.value)) {
    const secondToken = pop()

    if (ALL_KEYWORDS.includes(secondToken.value)) {
      throw { message: `Unexpected keyword '${secondToken.str}' here`, token: secondToken }
    }
    else if (!isLowerCase(secondToken.str)) {
      throw { message: "Common variables must be lowercase and all alphabetical", token: secondToken }
    }
    else if (firstToken.punctuation !== "") {
      throw { message: "Common variables must be all alphabetical (you can use punctuation only after their last word)", token: firstToken }
    }

    const variableName = `${firstToken.value} ${secondToken.value}`
    state.lastNamedVar = variableName
    return { variableName, punctuation: secondToken.punctuation }
  }

  // well then it must be a proper variable (or garbage)
  let variableName = ""
  let token = firstToken

  while (true) {
    if (ALL_KEYWORDS.includes(token.value)) {
      throw { message: `Unexpected keyword '${token.str}' here`, token }
    }
    else if (!isCapitalized(token.str)) {
      throw { message: "Proper variables must be capitalized and all alphabetical", token }
    }

    if (variableName) variableName += " "
    variableName += token.str

    if (!more()) break

    if (token.punctuation.endsWith(",")) {
      break  // a trailing comma ends the variable, in case we're in a function's argument list
    }

    const nextToken = peek()
    if (nextToken.type !== TokenType.DEFAULT || ALL_KEYWORDS.includes(nextToken.value) || !isCapitalized(nextToken.str)) break

    if (token.punctuation !== "") {
      // the variable has another word in it, so don't allow punctuation here
      throw { message: "Proper variables must be all alphabetical (you can use punctuation only after their last word)", token }
    }

    token = pop()
  }

  state.lastNamedVar = variableName
  return { variableName, punctuation: token.punctuation }
}

/**
 * Parses a type literal from a single token.
 * Returns an object with `literalType` and `literalValue` properties.
 */
function parseTypeLiteral(fromToken) {
  if (UNDEFINED.includes(fromToken.value))
    return { literalType: "undefined", literalValue: undefined }
  if (NULL.includes(fromToken.value))
    return { literalType: "null", literalValue: null }
  if (TRUE.includes(fromToken.value))
    return { literalType: "boolean", literalValue: true }
  if (FALSE.includes(fromToken.value))
    return { literalType: "boolean", literalValue: false }

  if (MAYBE.includes(fromToken.value)) {
    throw { message: `Type literal '${fromToken.str}' is reserved for future use`, token: fromToken }
  }

  throw { message: `Invalid type literal '${fromToken.str}'`, token: fromToken }
}

/**
 * Parses a poetic string literal from the given token list,
 * which is expected to be the end of a line (i.e. pass the result of popLine()), following "says".
 * Returns the string parsed, or the empty string if there are no tokens to parse.
 */
function parsePoeticStringLiteral(fromTokens) {
  let str = ""
  let space = ""

  for (const tokenNum in fromTokens) {
    const token = fromTokens[tokenNum]

    str += `${space}${token.str}${token.punctuation}`  // treat all token types the same here
    space = " "
  }

  return str
}

/**
 * Parses a poetic number literal from the given token list,
 * which is expected to be the end of a line (i.e. pass the result of popLine()), following is/was/were.
 * Returns the number parsed, or 0 if there are no tokens to parse.
 */
function parsePoeticNumberLiteral(fromTokens) {
  if (!fromTokens.length) return 0  // if there are no tokens on the line after the is/was/were keyword

  let numStr = ""
  let pendingDecimal = false
  let hasDecimal = false

  for (const tokenNum in fromTokens) {
    const words = fromTokens[tokenNum].str.split(/\s+/)  // the token could be a string literal, or multi-word keyword

    for (const wordNum in words) {
      const word = words[wordNum]

      if (pendingDecimal) {
        numStr += "."
        hasDecimal = true
      }

      const digit = countAlphabeticalChars(word) % 10
      numStr += digit

      if (!hasDecimal && word.includes(".")) pendingDecimal = true
    }
  }

  const num = numStr.includes(".") ? parseFloat(numStr) : parseInt(numStr)

  if (isNaN(num) || !isFinite(num)) {
    const firstToken = fromTokens[0]
    throw { message: `Invalid poetic number literal '${firstToken.str} ...' (${num})`, firstToken }
  }

  return num
}

/**
 * Parses and returns a numeric literal token's numeric value.
 */
function parseNumericLiteral(token) {
  const num = token.str.includes(".") ? parseFloat(token.str) : parseInt(token.str)

  if (isNaN(num) || !isFinite(num)) {
    throw { message: `Invalid numeric literal '${token.str}'  (${num})`, token }
  }

  return num
}

/**
 * Determines whether the current token starts a multi-word keyword, returning a boolean.
 * You must pass the current token, i.e. the last one popped; doing otherwise will break stuff.
 * You must also pass the multi-word keyword in lowercase and separated only by single spaces.
 *
 * If the current token does start a multi-word keyword, e.g. "take it to the top",
 * the tokens which complete the keyword ("it", "to", "the", and "top") are consumed and discarded;
 * otherwise, the token list remains untouched.
 */
function parseMultiWordKeyword(currentToken, keyword) {
  const words = keyword.split(" ")
  const upcomingCount = words.length - 1
  const tokens = [currentToken].concat(peekMany(upcomingCount))

  for (let index = 0; index < words.length; index++) {
    const token = tokens.shift()
    if (!token || token.type !== TokenType.DEFAULT || token.value !== words[index]) {
      return false
    }
  }

  for (let index = 0; index < upcomingCount; index++) pop()
  return true
}

/**
 * Determines whether the passed token appears to start a variable's name,
 * by being a pronoun, common variable, or proper variable.
 */
function startsVariable(token) {
  if (PRONOUNS.includes(token.value)) return true
  if (PREFIXES.includes(token.value)) return true
  if (isCapitalized(token.str) && !ALL_KEYWORDS.includes(token.value)) return true
  return false
}

module.exports = { parse }
