// Functions intended to make it easy to "step through" a list of Rockstar tokens.

// This is effectively a singleton, which maybe isn't ideal in some ways,
// but this structure makes usage really convenient...

const { TokenType } = require("./tokenType")

// our state; if the functions in this file were in a class, these would be our private properties
const state = {
  tokens: null,
  tokenIndex: 0
}

/**
 * Initializes the token list with the passed array of Rockstar tokens,
 * which is expected to have been generated by our tokenizer.
 */
function init(tokens) {
  state.tokens = tokens
  state.tokenIndex = 0
}

/**
 * Determines whether there are more tokens in the list,
 * skipping past any linebreak tokens by default (but not blank-line tokens).
 */
function more(skipLinebreaks = true) {
  try {
    peek(skipLinebreaks)
    return true
  }
  catch (err) {
    return false
  }
}

/**
 * Returns the next token from the list, without removing it from the list,
 * and skipping past any linebreak tokens by default (but not blank-line tokens).
 *
 * Throws if there are no more tokens, so it's good for when we syntactically need another token,
 * as the right things will happen more or less automatically if there's not one there for us.
 */
function peek(skipLinebreaks = true) {
  let index = state.tokenIndex

  while (true) {
    if (index >= state.tokens.length) {
      let index = state.tokens.length - 1
      while ([TokenType.LINEBREAK, TokenType.BLANK_LINE].includes(state.tokens[index].type)) index--
      throw { message: "Unexpected end of input", token: state.tokens[index] }
    }

    const token = state.tokens[index++]
    if (skipLinebreaks && token.type === TokenType.LINEBREAK) continue
    return token
  }
}

/**
 * Returns the next `count` tokens from the list, without removing them from the list,
 * and skipping past any linebreak tokens by default (but not blank-line tokens).
 * If fewer than `count` tokens remain in the list, the remainder of the list is returned.
 *
 * Since peekMany() doesn't throw when there are no more tokens, unlike peek(),
 * it should be used cautiously, likely only when some-or-none more tokens are expected.
 */
function peekMany(count, skipLinebreaks = true) {
  const peeked = []

  for (let index = state.tokenIndex; peeked.length < count; index++) {
    if (index >= state.tokens.length) break  // we'll return a partial list

    const token = state.tokens[index]
    if (skipLinebreaks && token.type === TokenType.LINEBREAK) continue
    peeked.push(token)
  }

  return peeked
}

/**
 * Returns the next token from the list, logically removing it from the list,
 * throwing if the next token is a numeric or string literal by default,
 * and skipping past any linebreak tokens by default (but not blank-line tokens).
 */
function pop(rejectLiteral = true, skipLinebreaks = true) {
  while (true) {
    if (state.tokenIndex >= state.tokens.length) {
      let index = state.tokens.length - 1
      while (index >= 0 && [TokenType.LINEBREAK, TokenType.BLANK_LINE].includes(state.tokens[index].type)) index--
      throw { message: "Unexpected end of input", token: state.tokens[index] }
    }

    const token = state.tokens[state.tokenIndex++]
    if (skipLinebreaks && token.type === TokenType.LINEBREAK) continue

    if (rejectLiteral && (token.type === TokenType.NUMERIC_LITERAL || token.type === TokenType.STRING_LITERAL)) {
      throw { message: "Unexpected string or numeric literal", token }
    }

    return token
  }
}

/**
 * Returns all remaining tokens on the current line, i.e. up to but not including the next linebreak token,
 * and discarding the linebreak token. Returns an array, which might of course be empty.
 */
function popLine() {
  const lineTokens = []

  while (more(false)) {
    const token = pop(false, false)
    if (token.type === TokenType.LINEBREAK) break
    lineTokens.push(token)
  }

  return lineTokens
}

/**
 * Rewinds the list of tokens so that the given token, which was previously popped,
 * is back at its head, and will be peeked/popped next.
 */
function rewind(toToken) {
  while (state.tokens[state.tokenIndex] !== toToken) {
    state.tokenIndex--

    if (state.tokenIndex < 0) {
      const tokenStr = JSON.stringify(toToken, null, 1).replace(/\s+/g, " ")
      throw new Error(`Unable to rewind to token ${tokenStr}`)
    }
  }
}

module.exports = { init, more, peek, peekMany, pop, popLine, rewind }
